<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MSDF Texture Tester</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #222;
            color: white;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 1px solid #555;
            background: #000;
        }
        .controls {
            margin: 20px 0;
        }
        input[type="file"] {
            margin: 10px 0;
            padding: 5px;
        }
        input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        label {
            display: inline-block;
            width: 100px;
            margin: 5px 0;
        }
        .info {
            margin: 20px 0;
            padding: 10px;
            background: #333;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <h1>MSDF Texture Tester</h1>
    <div class="info">
        Upload your MSDF texture to test the median-of-three reconstruction. 
        Adjust scale and smoothness to see how the distance field behaves.
    </div>
    
    <div class="controls">
        <input type="file" id="fileInput" accept="image/*">
        <br>
        <label>Scale:</label>
        <input type="range" id="scaleSlider" min="0.1" max="5" step="0.1" value="1">
        <span id="scaleValue">1.0</span>
        <br>
        <label>Smoothness:</label>
        <input type="range" id="smoothSlider" min="0" max="0.2" step="0.01" value="0.05">
        <span id="smoothValue">0.05</span>
        <br>
        <label>Background:</label>
        <input type="color" id="bgColor" value="#000000">
        <label>Text Color:</label>
        <input type="color" id="textColor" value="#ffffff">
    </div>
    
    <canvas id="canvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        // Vertex shader
        const vertexShaderSource = `
            attribute vec2 a_position;
            attribute vec2 a_texCoord;
            varying vec2 v_texCoord;
            uniform vec2 u_resolution;
            uniform float u_scale;
            
            void main() {
                vec2 zeroToOne = a_position / u_resolution;
                vec2 zeroToTwo = zeroToOne * 2.0;
                vec2 clipSpace = zeroToTwo - 1.0;
                gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
                v_texCoord = a_texCoord * u_scale;
            }
        `;

        // Fragment shader with MSDF reconstruction
        const fragmentShaderSource = `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform float u_smoothness;
            uniform vec3 u_bgColor;
            uniform vec3 u_textColor;
            varying vec2 v_texCoord;
            
            float median(float r, float g, float b) {
                return max(min(r, g), min(max(r, g), b));
            }
            
            void main() {
                vec3 msd = texture2D(u_texture, v_texCoord).rgb;
                float sd = median(msd.r, msd.g, msd.b);
                
                // Convert to signed distance
                float distance = sd - 0.5;
                
                // Apply smoothing
                float alpha = smoothstep(-u_smoothness, u_smoothness, distance);
                
                // Mix background and text colors
                vec3 color = mix(u_bgColor, u_textColor, alpha);
                
                gl_FragColor = vec4(color, 1.0);
            }
        `;

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            
            return program;
        }

        // Create shaders and program
        const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
        const program = createProgram(gl, vertexShader, fragmentShader);

        // Get locations
        const positionLocation = gl.getAttribLocation(program, 'a_position');
        const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');
        const resolutionLocation = gl.getUniformLocation(program, 'u_resolution');
        const textureLocation = gl.getUniformLocation(program, 'u_texture');
        const scaleLocation = gl.getUniformLocation(program, 'u_scale');
        const smoothnessLocation = gl.getUniformLocation(program, 'u_smoothness');
        const bgColorLocation = gl.getUniformLocation(program, 'u_bgColor');
        const textColorLocation = gl.getUniformLocation(program, 'u_textColor');

        // Create buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        
        // Full screen quad
        const positions = [
            0, 0,
            canvas.width, 0,
            0, canvas.height,
            0, canvas.height,
            canvas.width, 0,
            canvas.width, canvas.height,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        const texCoordBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
        
        const texCoords = [
            0, 0,
            1, 0,
            0, 1,
            0, 1,
            1, 0,
            1, 1,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

        let texture = null;

        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            return [r, g, b];
        }

        function render() {
            if (!texture) return;

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);

            // Set uniforms
            gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
            gl.uniform1f(scaleLocation, parseFloat(document.getElementById('scaleSlider').value));
            gl.uniform1f(smoothnessLocation, parseFloat(document.getElementById('smoothSlider').value));
            
            const bgColor = hexToRgb(document.getElementById('bgColor').value);
            const textColor = hexToRgb(document.getElementById('textColor').value);
            gl.uniform3f(bgColorLocation, bgColor[0], bgColor[1], bgColor[2]);
            gl.uniform3f(textColorLocation, textColor[0], textColor[1], textColor[2]);

            // Bind texture
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.uniform1i(textureLocation, 0);

            // Set up attributes
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
            gl.enableVertexAttribArray(texCoordLocation);
            gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);

            // Draw
            gl.drawArrays(gl.TRIANGLES, 0, 6);
        }

        function loadTexture(image) {
            texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            
            // Set parameters for MSDF textures
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            
            render();
        }

        // Event listeners
        document.getElementById('fileInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                const img = new Image();
                img.onload = function() {
                    loadTexture(img);
                };
                img.src = URL.createObjectURL(file);
            }
        });

        document.getElementById('scaleSlider').addEventListener('input', function(e) {
            document.getElementById('scaleValue').textContent = e.target.value;
            render();
        });

        document.getElementById('smoothSlider').addEventListener('input', function(e) {
            document.getElementById('smoothValue').textContent = e.target.value;
            render();
        });

        document.getElementById('bgColor').addEventListener('change', render);
        document.getElementById('textColor').addEventListener('change', render);
    </script>
</body>
</html>